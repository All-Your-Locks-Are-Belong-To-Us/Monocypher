.Dd August 26, 2017
.Dt CRYPTO_CHACHA20_ENCRYPT 3MONOCYPHER
.Os
.Sh NAME
.Nm crypto_chacha20_encrypt ,
.Nm crypto_chacha20_init ,
.Nm crypto_chacha20_x_init ,
.Nm crypto_chacha20_stream ,
.Nm crypto_chacha20_set_ctr
.Nd Chacha20 encryption
.Sh SYNOPSIS
.In monocypher.h
.Ft void
.Fo crypto_chacha20_init
.Fa "crypto_chacha_ctx *ctx"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[8]"
.Fc
.Ft void
.Fo crypto_chacha20_x_init
.Fa "crypto_chacha_ctx *ctx"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fc
.Ft void
.Fo crypto_chacha20_encrypt
.Fa "crypto_chacha_ctx *ctx"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft void
.Fo crypto_chacha20_stream
.Fa "crypto_chacha_ctx *ctx"
.Fa "uint8_t *stream"
.Fa "size_t size"
.Fc
.Ft void
.Fo crypto_chacha20_set_ctr
.Fa "crypto_chacha_ctx *ctx"
.Fa "uint64_t ctr"
.Fc
.Sh DESCRIPTION
These functions provide an incremental interface for the Chacha20
encryption primitive.
.Pp
Chacha20 is a low-level primitive.
Consider using authenticated encryption, implemented by
.Xr crypto_lock 3monocypher .
.Pp
.Fn crypto_chacha20_init
initialises the
.Vt crypto_chacha_ctx
context.
It needs a 32-byte secret
.Fa key
and an 8-byte
.Fa nonce .
The nonce must be used only once per secret key (repeating them
destroys confidentiality).  Counters and (unique) message numbers can
be used as nonces.
Random numbers
.Em cannot :
8-byte nonces are too small to prevent accidental reuse.
.Pp
.Fn crypto_chacha20_x_init
initialises the
.Vt crypto_chacha_ctx
context.
It needs a 32-byte secret
.Fa key
and a 24-byte
.Fa nonce .
The nonce is big enough to be selected at random.
See
.Xr intro 3monocypher
about generating random numbers (use the operating system's random
number generator).
.Pp
The recommended initialisation routine is
.Fn crypto_chacha20_x_init .
The ability to use random nonces makes it easier to use securely, and
the performance hit is negligible in practice.
.Pp
The following functions need an initialised context to work properly.
Calling them with an uninitialised context triggers undefined
behaviour.
.Pp
.Fn crypto_chacha20_encrypt
encrypts the
.Fa plain_text
by XORing it with a pseudo-random stream of
numbers, seeded by the provided
.Vt crypto_chacha_ctx
context.
Once the encryption is done, the context is updated to allow
subsequent calls of
.Fn crypto_chacha20_encrypt
on the rest of the message, if any.
.Pp
The
.Fa plain_text
and
.Fa cipher_text
may point to the same buffer for in-place encryption.
Otherwise, the buffers they point to
.Em must not overlap .
.Pp
The
.Fa plain_text
pointer is allowed to be
.Dv NULL
(0), in which case it will be interpreted as an all zero input.
The cipher_text will then contain the raw Chacha20 stream.
.Pp
Decryption is the same as encryption.
To Decrypt the
.Fa cipher_text ,
encrypt it again with the same
.Fa key
and
.Fa nonce .
You will likely want to wipe the key and context when you are done with
encryption or decryption.
Use
.Xr crypto_wipe 3monocypher
to wipe them.
.Pp
.Fn crypto_chacha20_stream
is the same as
.Fn crypto_chacha20_encrypt
with
.Fa plain_text
being
.Dv NULL .
This is useful as a user space random number generator.
While
.Sy this must not be used as a cryptographic random number generator ,
it can be handy outside of a security context.
Deterministic procedural generation and reproducible property-based
tests come to mind.
.Pp
.Fn crypto_chacha20_set_ctr
resets the internal counter of the
.Vt crypto_chacha_ctx
to the value specified in
.Fa ctr .
Resuming the encryption will use the stream at the block
.Fa ctr
(which is the byte
.Ql ctr \(mu 64 ) .
This can be used to encrypt (or decrypt) part of a long message, or to
implement some AEAD constructions such as the one described in RFC
7539 (not implemented in Monocypher because of its complexity and
limitations).
Be careful when using this not to accidentally reuse parts of the
random stream.
This would destroy confidentiality.
.Sh RETURN VALUES
These functions return nothing.
They cannot fail.
.Sh EXAMPLES
Simple encryption:
.Bd -literal -offset indent
const uint8_t key        [ 32];  /* Secret random key              */
const uint8_t nonce      [ 24];  /* Unique nonce (possibly random) */
const uint8_t plain_text [500];  /* Message to be encrypted        */
uint8_t       cipher_text[500];  /* Will be the encrypted message  */
crypto_chacha_ctx ctx;
crypto_chacha20_x_init(&ctx, key, nonce);
crypto_chacha20_encrypt(&ctx, cipher_text, plain_text, 500);
/* Wipe secrets if they're no longer needed */
crypto_wipe(key,        sizeof(key));
crypto_wipe(&ctx,       sizeof(ctx));
crypto_wipe(plain_text, sizeof(plain_text));
.Ed
.Pp
To decrypt the above:
.Bd -literal -offset indent
const uint8_t key        [ 32];  /* Same key as above              */
const uint8_t nonce      [ 24];  /* Same nonce as above            */
const uint8_t cipher_text[500];  /* Encrypted message              */
uint8_t plain_text       [500];  /* Will be the decrypted message  */
crypto_chacha_ctx ctx;
crypto_chacha20_x_init(&ctx, key, nonce);
crypto_chacha20_encrypt(&ctx, plain_text, cipher_text, 500);
/* Wipe secrets if they are no longer needed */
crypto_wipe(key,  sizeof(key));
crypto_wipe(&ctx, sizeof(ctx));
/* The plain text likely needs to be processed before you wipe it */
.Ed
.Pp
Encryption chunk by chunk (same as simple encryption):
.Bd -literal -offset indent
const uint8_t key        [ 32];  /* Secret random key              */
const uint8_t nonce      [ 24];  /* Unique nonce (possibly random) */
const uint8_t plain_text [500];  /* Message to be encrypted        */
uint8_t       cipher_text[500];  /* Will be the encrypted message  */
crypto_chacha_ctx ctx;
crypto_chacha20_x_init(&ctx, key, nonce);
for(int i = 0; i < 500; i += 100) {
    crypto_chacha20_encrypt(&ctx, cipher_text+i, plain_text+i, 100);
}
/* Wipe secrets if they are no longer needed */
crypto_wipe(key,        sizeof(key));
crypto_wipe(&ctx,       sizeof(ctx));
crypto_wipe(plain_text, sizeof(plain_text));
.Ed
.Pp
In place encryption (same results as simple encryption):
.Bd -literal -offset indent
const uint8_t key     [ 32];  /* Secret random key               */
const uint8_t nonce   [ 24];  /* Unique nonce (possibly random)  */
uint8_t       message [500];  /* Buffer to be encrypted in place */
crypto_chacha_ctx ctx;
crypto_chacha20_x_init(&ctx, key, nonce);
crypto_chacha20_encrypt(&ctx, message, message, 500);
crypto_wipe(key,  sizeof(key));
crypto_wipe(&ctx, sizeof(ctx));
/* Wipe secrets if they are no longer needed */
crypto_wipe(key,  sizeof(key));
crypto_wipe(&ctx, sizeof(ctx));
.Ed
.Pp
Simple encryption with a small,
.Em not
random nonce:
.Bd -literal -offset indent
const uint8_t key        [ 32];  /* Secret, random key        */
const uint8_t nonce      [  8];  /* Unique nonce (NOT random) */
const uint8_t plain_text [500];  /* Message to be encrypted   */
crypto_chacha_ctx ctx;
crypto_chacha20_init(&ctx, key, nonce);
crypto_chacha20_encrypt(&ctx, cipher_text, plain_text, 500);
crypto_wipe(key,  sizeof(key));
crypto_wipe(&ctx, sizeof(ctx));
/* Wipe secrets if they are no longer needed */
crypto_wipe(key,        sizeof(key));
crypto_wipe(&ctx,       sizeof(ctx));
crypto_wipe(plain_text, sizeof(plain_text));
.Ed
.Pp
Encryption by jumping around (don't do that):
.Bd -literal -offset indent
const uint8_t key        [ 32];  /* Secret random key              */
const uint8_t nonce      [ 24];  /* Unique nonce (possibly random) */
const uint8_t plain_text [500];  /* Message to be encrypted        */
uint8_t       cipher_text[500];  /* Will be the encrypted message  */
crypto_chacha_ctx ctx;
crypto_chacha20_x_init(&ctx, key, nonce);
/* Encrypt the second part of the message first... */
crypto_chacha20_set_ctr(&ctx, 3);
crypto_chacha20_encrypt(&ctx,
                        cipher_text + (3 * 64),
                        plain_text  + (3 * 64),
                        500         - (3 * 64));
/* ...then encrypt the first part */
crypto_chacha20_set_ctr(&ctx, 0);
crypto_chacha20_encrypt(&ctx, cipher_text, plain_text, 3 * 64);
/* Wipe secrets if they are no longer needed */
crypto_wipe(key,        sizeof(key));
crypto_wipe(&ctx,       sizeof(ctx));
crypto_wipe(plain_text, sizeof(plain_text));
.Ed
.Sh SEE ALSO
.Xr crypto_lock 3monocypher ,
.Xr crypto_wipe 3monocypher ,
.Xr intro 3monocypher
.Sh STANDARDS
These functions implement Chacha20 and XChacha20.
Chacha20 is described in RFC 7539.
XChacha20 derives from Chacha20 the same way XSalsa20 derives from
Salsa20, and benefits from the same security reduction (proven secure
as long as Chacha20 itself is secure).
.Sh SECURITY CONSIDERATIONS
.Ss Encrypted does not mean secure
Chacha20 only protects against eavesdropping, not forgeries.
Most applications need protection against forgeries to be properly
secure.
To ensure the integrity of a message, use Blake2b in keyed mode, or
authenticated encryption; see
.Xr crypto_blake2b 3monocypher
and
.Xr crypto_lock 3monocypher
.Ss Nonce reuse
Repeating a nonce with the same key exposes the XOR of two or more
plaintext messages, effectively destroying confidentiality.
.Pp
For the same reason,
.Sy do not select small nonces at random .
The
.Fn crypto_chacha20_init
nonce spans only 64 bits, which is small enough to trigger accidental
reuses.
A counter should be used instead.
If multiple parties send out messages, Each can start with an initial
nonce of 0, 1 .. n-1 respectively, and increment them by n for each
new message (make sure the counters never wrap around).
.Ss Secure random number generation
Do not use these functions as cryptographic random number generator.
Always use the operating system's random number generator for
cryptographic purposes, see
.Xr intro 3monocypher .
.Ss Protection against side channels
Secrets should not dwell in memory longer than needed.
Use
.Xr crypto_wipe 3monocypher
to erase secrets you no longer need.
For Chacha20, this means the context, the key, and in some cases the
plain text itself.
