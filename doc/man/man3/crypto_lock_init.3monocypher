.Dd October 14, 2017
.Dt CRYPTO_LOCK_INIT 3MONOCYPHER
.Os
.Sh NAME
.Nm crypto_lock_init ,
.Nm crypto_lock_auth ,
.Nm crypto_lock_encrypt ,
.Nm crypto_lock_update ,
.Nm crypto_lock_final ,
.Nm crypto_unlock_update ,
.Nm crypto_unlock_final
.Nd incremental authenticated encryption with authenticated data
.Sh SYNOPSIS
.In monocypher.h
.Ft void
.Fo crypto_lock_init
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fc
.Ft void
.Fo crypto_lock_auth
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t *ad"
.Fa "size_t ad_size"
.Fc
.Ft void
.Fo crypto_lock_update
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft void
.Fo crypto_lock_final
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t mac[16]"
.Fc
.Ft void
.Fo crypto_unlock_update
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t *plain_text"
.Fa "const uint8_t *cipher_text"
.Fa "size_t text_size"
.Fc
.Ft int
.Fo crypto_unlock_final
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t mac[16]"
.Fc
.Ft void
.Fo crypto_lock_encrypt
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Sh DESCRIPTION
These functions are variants of
.Xr crypto_lock 3monocypher ,
.Xr crypto_unlock 3monocypher ,
.Xr crypto_aead_lock 3monocypher
and
.Xr crypto_aead_unlock 3monocypher .
Prefer those simpler functions if possible.
.Pp
This incremental interface allows splitting up decryption and
authentication of messages too large to fit into a single buffer
or to handle individual pieces of data located in different buffers.
The arguments are the same as described for the direct interface on
.Xr crypto_lock 3monocypher .
.Pp
This interface uses four steps:
.Bl -bullet
.It
Initialisation with
.Fn crypto_lock_init .
This sets up a context for encryption or decryption (the same function
is used for both).
.It
Authentication with
.Fn crypto_lock_auth .
This authenticates (or verifies) additional data, if any.
This step is optional.
.It
Update, with
.Fn crypto_lock_update
for encryption, or
.Fn crypto_unlock_update
for decryption.
This encrypts (or decrypts) and authenticates (or verifies) part of
the secret message.
.It
Final, with
.Fn crypto_lock_final
to generate the MAC, or
.Fn crypto_unlock_final
to verify the MAC.
.El
.Pp
Because the incremental interface interleaves encryption and
authentication, it treats corrupted messages three times slower than
the direct interface.
Users who expect a high corruption rate may want a different approach.
.Pp
The
.Fn crypto_lock_encrypt
function encrypts or decrypts data
.Em without authenticating it .
It is meant as a building block.
Used with
.Fn crypto_lock_auth ,
it enables various AEAD constructions.
Most users don't need it.
Prefer
.Fn crypto_lock_update
and
.Fn crypto_unlock_update
instead.
.Sh RETURN VALUES
The
.Fn crypto_lock_init ,
.Fn crypto_lock_auth ,
.Fn crypto_lock_encrypt ,
.Fn crypto_lock_update ,
and
.Fn crypto_lock_final
functions return nothing.
They cannot fail.
.Pp
The
.Fn crypto_unlock_final
function returns 0 on success or -1 if the message was corrupted.
Corruption can happen because of transmission errors, programmer
error, or attacker interference.
.Em Always check the return value.
.Sh EXAMPLES
Encryption:
.Bd -literal -offset indent
const uint8_t key        [ 32]; /* session key                 */
const uint8_t nonce      [ 32]; /* unique per session key      */
const uint8_t ad         [500]; /* optional additional data    */
const uint8_t plain_text [500]; /* secret message              */
uint8_t       cipher_text[500]; /* encrypted message           */
uint8_t       mac        [ 16]; /* message authentication code */

/* Set up initial context */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);
crypto_wipe(key, 32);      /* wipe the key if no longer needed */

/* Authenticate additional data, if any */
for (size_t i = 0; i < 500; i += 100) {
    crypto_lock_auth(&ctx, ad + i, 100);
}

/* Encrypt message */
for (size_t i = 0; i < 500; i += 100) {
    crypto_lock_update(&ctx, cipher_text + i, plain_text + i, 100);
    /* wipe the secret message if no longer needed */
    crypto_wipe(plain_text + i, 100);
}

/* Produce the MAC */
crypto_lock_final(&ctx, mac);
.Ed
.Pp
To decrypt the above:
.Bd -literal -offset indent
const uint8_t key        [ 32]; /* session key              */
const uint8_t nonce      [ 32]; /* unique per session key   */
const uint8_t mac        [ 16]; /* transmitted MAC          */
const uint8_t ad         [500]; /* optional additional data */
const uint8_t cipher_text[500]; /* encrypted message        */
uint8_t       plain_text [500]; /* secret message           */

/* Set up initial context */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);
crypto_wipe(key, 32);   /* wipe the key if no longer needed */

/* Authenticate additional data, if any */
for (size_t i = 0; i < 500; i += 100) {
    crypto_lock_auth(&ctx, ad + i, 100);
}

/* Decrypt message */
for (size_t i = 0; i < 500; i += 100) {
    crypto_unlock_update(&ctx, plain_text + i, cipher_text + i, 100);
}

/* Check the MAC */
if (crypto_unlock_final(&ctx, mac)) {
    /* corrupted message, abort processing */
} else {
    /* genuine message */
}
.Ed
.Pp
In place Encryption (without additional data for clarity):
.Bd -literal -offset indent
const uint8_t key   [ 32]; /* session key                 */
const uint8_t nonce [ 32]; /* unique per session key      */
uint8_t       text  [500]; /* message                     */
uint8_t       mac   [ 16]; /* message authentication code */

/* Set up initial context */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);
crypto_wipe(key, 32); /* wipe the key if no longer needed */

/* Encrypt message */
for (size_t i = 0; i < 500; i += 100) {
    crypto_lock_update(&ctx, text + i, text + i, 100);
}

/* Produce the MAC */
crypto_lock_final(&ctx, mac);
.Ed
.Sh SEE ALSO
.Xr crypto_aead_lock 3monocypher ,
.Xr crypto_aead_unlock 3monocypher ,
.Xr crypto_key_exchange 3monocypher ,
.Xr crypto_lock 3monocypher ,
.Xr crypto_unlock 3monocypher ,
.Xr crypto_wipe 3monocypher ,
.Xr intro 3monocypher
.Sh STANDARDS
These functions implement the XChacha20 (encryption) and Poly1305
(MAC) primitives.
Chacha20 and Poly1305 are described in RFC 7539.
XChacha20 derives from Chacha20 the same way XSalsa20 derives from
Salsa20, and benefits from the same security reduction (proven secure
as long as Chacha20 itself is secure).
