.Dd August 25, 2017
.Dt CRYPTO_LOCK 3MONOCYPHER
.Os
.Sh NAME
.Nm crypto_lock ,
.Nm crypto_unlock
.Nd authenticated encryption
.Sh SYNOPSIS
.In monocypher.h
.Ft void
.Fo crypto_lock
.Fa "uint8_t mac[16]"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft int
.Fo crypto_unlock
.Fa "uint8_t *plain_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t mac[16]"
.Fa "const uint8_t *cipher_text"
.Fa "size_t text_size"
.Fc
.Ft void
.Fo crypto_lock_init
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fc
.Ft void
.Fo crypto_lock_auth
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t *ad"
.Fa "size_t ad_size"
.Fc
.Ft void
.Fo crypto_lock_update
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft void
.Fo crypto_lock_final
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t mac[16]"
.Fc
.Ft void
.Fo crypto_unlock_update
.Fa "crypto_lock_ctx *ctx"
.Fa "uint8_t *plain_text"
.Fa "const uint8_t *cipher_text"
.Fa "size_t text_size"
.Fc
.Ft int
.Fo crypto_unlock_final
.Fa "crypto_lock_ctx *ctx"
.Fa "const uint8_t mac[16]"
.Fc
.Sh DESCRIPTION
Encryption makes your messages unreadable to eavesdroppers.
Authentication ascertain the origin and integrity of the messages you
read.
Both are important.
Without encryption, you give away all your secrets, and without
authentication, you can fall prey to forgeries (messages that look
legitimate, but actually come from an attacker).
A clever attacker may even leverage forgeries to steal your secrets.
Always authenticate your messages.
.Ss Direct interface
The
.Fn crypto_lock
function encrypts and authenticates a plaintext.
It can be decrypted by the
.Fn crypto_unlock
function.
The arguments are:
.Bl -tag -width Ds
.It Fa key
a 32-byte session key, shared between you and the recipient.
It must be secret (unknown to the attacker) and random (unpredictable to
an attacker).
Of course, one does not simply transmit this key over the network.
Meeting physically or performing a Diffie Hellman key exchange (see
.Xr crypto_key_exchange 3monocypher )
are preferable methods.
.It Fa nonce
a 24-byte number, used only once with any given session key.
It does not have to be secret or random.
But you must
.Em never
reuse that number with the same key.
If you do, the attacker will have access to the XOR of 2 different
messages, allowing decryption,
.Em and
the ability to forge messages in your stead.
The easiest (and recommended) way to generate this nonce is to
select it at random.
See
.Xr intro 3monocypher
about random number generation (in short: use your operating
system's random number generator).
.It Fa mac
a 16-byte
.Em message authentication code (MAC) ,
that only you could have produced.
This guarantee cannot be upheld once an attacker learns your session
key, or sees 2 messages with the same nonce.
Seriously, do not reuse the nonce.
The MAC is intended to be sent along with the ciphertext.
.It Fa plain_text
the secret you want to send.
Of course, it must be unknown to an attacker.
Keep in mind however that the
.Em length
of the plaintext, unlike its content, is not made secret by these
functions.
Make sure your protocol does not leak secret information with the length
of messages.
This has happened before with variable-length voice
encoding software.
Solutions to mitigate this include constant-length encodings and
padding.
.It Fa cipher_text
the encrypted message (same length as the plaintext
message).
Transmit it over the network so the recipient can decrypt
and read it.
Note:
.Fa cipher_text is allowed to have the same value as
.Fa plain_text .
If so, encryption or decryption will happen in place.
.El
.Pp
Unlocking proceeds in two steps: first, we authenticate the ciphertext
with the provided MAC.
If it has been corrupted, the
.Fn crypto_aead_unlock
function returns immediately,
without decrypting the message.
If the message is genuine, the
.Fn crypto_aead_unlock
function decrypts the ciphertext.
.Em Always check the return value .
.Ss Incremental interface
The incremental interface allows to split up decryption and
authentication of larger messages too large to fit into a single buffer
or to handle individual pieces of data located in different buffers.
.Pp
The arguments are the same as described for the direct interface.
It instead uses three steps:
.Bl -bullet
.It
initialisation, where we set up a context for encryption/decryption and
authentication;
.It
update, where we encrypt/decrypt and incrementally generate the MAC;
.It
final, where we generate/check the MAC.
.El
.Pp
Because the incremental interface interleaves both encryption and
authentication,
.Sy a message with a mismatched MAC is three times slower
to process than when using the direct interface.
The direct interface checks the MAC first and only then proceeds to
decrypt.
If you expect to frequently encounter messages whose MAC mismatches,
especially large messages, you may want to forgo the incremental
interface for a different approach.
.Pp
.Sy Both encryption and decryption
are initialized with
.Fn crypto_lock_init .
If you need to authenticate data without encrypting like with
.Xr crypto_aead_lock 3monocypher ,
plaintext data can be authenticated with
.Fn crypto_lock_auth .
Calls to
.Fn crypto_lock_auth
.Em can
be interleaved with calls to
.Fn crypto_lock_update
and
.Fn crypto_unlock_update .
.Pp
.Sy For encryption,
.Fn crypto_lock_update
authenticates and encrypts the data;
.Fn crypto_lock_final
generates the MAC.
.Sy For decryption ,
.Fn crypto_unlock_update
authenticates and decrypts the data;
.Fn crypto_unlock_final
checks the MAC.
.Em Always check the return value .
.Sh RETURN VALUES
The
.Fn crypto_lock ,
.Fn crypto_lock_init ,
.Fn crypto_lock_auth ,
.Fn crypto_lock_update ,
and
.Fn crypto_lock_final
functions return nothing.
They cannot fail.
.Pp
The
.Fn crypto_unlock
and
.Fn crypto_unlock_final
functions return 0 on success or -1 if the message was corrupted
(i.e.
.Fa mac
mismatched the combination of
.Fa key ,
.Fa nonce
and
.Fa cipher_text ) .
Corruption can happen because of transmission errors, programmer error
(e.g. failed to parse the protocol properly and thus supplied only part
of the expected
.Fa cipher_text )
or an attacker's interference.
.Sh EXAMPLES
.Ss Direct interface
Encryption:
.Bd -literal -offset indent
uint8_t key[32], nonce[24];
uint8_t mac[16];
char plain_text[] = "This does not have to be literally text.";
uint8_t cipher_text[51]; /* strlen(plain_text) + terminating NUL */

/* ...Generate a key, as well as a random nonce... */

crypto_lock(mac, cipher_text, key, nonce, plain_text,
        sizeof(plain_text));

/* You can now transmit over the network:
 * - cipher_text
 * - nonce
 * - mac
 */
.Ed
.Pp
To decrypt the above:
.Bd -literal -offset indent
uint8_t key[32], nonce[24];
uint8_t mac[16];
char plain_text[51]; /* strlen(plain_text) + terminating NUL */
uint8_t cipher_text[51];
int ret;

/* Ensure that the key and nonce match the ones used in the
 * encryption process.
 *
 * Now read mac and cipher_text from the network; nonce as well if it
 * was sent along.
 */

ret = crypto_unlock(plain_text, key, nonce, mac, cipher_text,
        sizeof(cipher_text));
if (ret != 0) {
        /* Message corrupted; possibly an attacker is interfering
         * with the connection.
         */
}
.Ed
.Ss Incremental interface
Useful for decrypting huge inputs.
This time, decryption is performed regardless of whether the message
is corrupted or not.
This may be relevant if you expect a high rate of corrupted messages.
.Pp
Encryption:
.Bd -literal -offset indent
/* Prepare the key, nonce, and input */

/* First, initialise the context */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);

/* Second, authenticate the additional data, if any. */
crypto_lock_auth(&ctx, ad1, ad_size1);
crypto_lock_auth(&ctx, ad2, ad_size2);
crypto_lock_auth(&ctx, ad3, ad_size3);

/* Third, encrypt the plain text */
crypto_lock_update(&ctx, cipher1, plain1, text_size1);
crypto_lock_update(&ctx, cipher2, plain2, text_size2);
crypto_lock_update(&ctx, cipher3, plain2, text_size3);

/* Finally, compute the authentication code */
crypto_lock_final (&ctx, mac);
.Ed
.Pp
Make sure you authenticate the additional data before you begin the
encryption, or the mac won't be compatible with the direct interface.
.Pp
To decrypt the above:
.Bd -literal -offset indent
/* First, initialise the context.
 * Use the key and nonce that were used for encryption.
 */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);

/* Second, authenticate the additional data, if any. */
crypto_lock_auth(&ctx, ad1, ad_size1);
crypto_lock_auth(&ctx, ad2, ad_size2);
crypto_lock_auth(&ctx, ad3, ad_size3);

/* Third, decrypt the cipher text */
crypto_unlock_update(&ctx, re_plain1, cipher1, text_size1);
crypto_unlock_update(&ctx, re_plain2, cipher2, text_size2);
crypto_unlock_update(&ctx, re_plain3, cipher3, text_size3);

/* Finally, check the authentication code */
if (crypto_unlock_final(&ctx, mac2)) {
    /* Message corrupted. */
} else {
    /* Decryption went well. */
}
.Ed
.Pp
To authenticate without decrypting at all:
.Bd -literal -offset indent
/* First, initialise the context.
 * Use the key and nonce that were used for encryption.
 */
crypto_lock_ctx ctx;
crypto_lock_init(&ctx, key, nonce);

/* Second, authenticate the additional data, if any. */
crypto_lock_auth(&ctx, ad1, ad_size1);
crypto_lock_auth(&ctx, ad2, ad_size2);
crypto_lock_auth(&ctx, ad3, ad_size3);

/* Third, authenticate the cipher text */
crypto_lock_auth(&ctx, re_plain1, cipher1, text_size1);
crypto_lock_auth(&ctx, re_plain2, cipher2, text_size2);
crypto_lock_auth(&ctx, re_plain3, cipher3, text_size3);

/* Finally, check the authentication code */
if (crypto_unlock_final(&ctx, mac2)) {
    /* Message corrupted. */
} else {
    /* Message authentic. */
}
.Ed
.Sh SEE ALSO
.Xr crypto_aead_lock 3monocypher ,
.Xr crypto_aead_unlock 3monocypher ,
.Xr crypto_key_exchange 3monocypher ,
.Xr intro 3monocypher
.Sh IMPLEMENTATION DETAILS
These functions implement the XChacha20 (encryption) and Poly1305 (MAC)
primitives.
