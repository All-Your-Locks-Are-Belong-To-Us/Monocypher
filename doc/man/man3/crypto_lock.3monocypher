.Dd August 25, 2017
.Dt CRYPTO_LOCK 3MONOCYPHER
.Os
.Sh NAME
.Nm crypto_aead_lock ,
.Nm crypto_aead_unlock ,
.Nm crypto_lock ,
.Nm crypto_unlock
.Nd authenticated encryption (optionally with additional data)
.Sh SYNOPSIS
.In monocypher.h
.Ft void
.Fo crypto_lock
.Fa "uint8_t mac[16]"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft int
.Fo crypto_unlock
.Fa "uint8_t *plain_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t mac[16]"
.Fa "const uint8_t *cipher_text"
.Fa "size_t text_size"
.Fc
.Ft void
.Fo crypto_aead_lock
.Fa "uint8_t mac[16]"
.Fa "uint8_t *cipher_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t *ad"
.Fa "size_t ad_size"
.Fa "const uint8_t *plain_text"
.Fa "size_t text_size"
.Fc
.Ft int
.Fo crypto_aead_unlock
.Fa "uint8_t *plain_text"
.Fa "const uint8_t key[32]"
.Fa "const uint8_t nonce[24]"
.Fa "const uint8_t mac[16]"
.Fa "const uint8_t *ad"
.Fa "size_t ad_size"
.Fa "const uint8_t *cipher_text"
.Fa "size_t text_size"
.Fc
.Sh DESCRIPTION
Encryption makes your messages unreadable to eavesdroppers.
Authentication ascertain the origin and integrity of the messages you
read.
Both are important.
Without encryption, you give away all your secrets, and without
authentication, you can fall prey to forgeries (messages that look
legitimate, but actually come from an attacker).
A clever attacker may even leverage forgeries to steal your secrets.
Always authenticate your messages.
.Pp
The
.Fn crypto_lock
function encrypts and authenticates a plaintext.
It can be decrypted by the
.Fn crypto_unlock
function.
The arguments are:
.Bl -tag -width Ds
.It Fa key
a 32-byte session key, shared between you and the recipient.
It must be secret (unknown to the attacker) and random (unpredictable to
an attacker).
Of course, one does not simply transmit this key over the network.
Meeting physically or performing a Diffie Hellman key exchange (see
.Xr crypto_key_exchange 3monocypher )
are preferable methods.
.It Fa nonce
a 24-byte number, used only once with any given session key.
It does not have to be secret or random.
But you must
.Em never
reuse that number with the same key.
If you do, the attacker will have access to the XOR of 2 different
messages, allowing decryption,
.Em and
the ability to forge messages in your stead.
The easiest (and recommended) way to generate this nonce is to
select it at random.
See
.Xr intro 3monocypher
about random number generation (in short: use your operating
system's random number generator).
.It Fa mac
a 16-byte
.Em message authentication code (MAC) ,
that only you could have produced.
This guarantee cannot be upheld once an attacker learns your session
key, or sees 2 messages with the same nonce.
Seriously, do not reuse the nonce.
The MAC is intended to be sent along with the ciphertext.
.It Fa plain_text
the secret you want to send.
Of course, it must be unknown to an attacker.
Keep in mind however that the
.Em length
of the plaintext, unlike its content, is not made secret by these
functions.
Make sure your protocol does not leak secret information with the length
of messages.
This has happened before with variable-length voice
encoding software.
Solutions to mitigate this include constant-length encodings and
padding.
.It Fa cipher_text
the encrypted message (same length as the plaintext
message).
Transmit it over the network so the recipient can decrypt
and read it.
Note:
.Fa cipher_text is allowed to have the same value as
.Fa plain_text .
If so, encryption or decryption will happen in place.
.El
.Pp
Unlocking proceeds in two steps: first, we authenticate the ciphertext
with the provided MAC.
If it has been corrupted, the
.Fn crypto_aead_unlock
function returns immediately,
without decrypting the message.
If the message is genuine, the
.Fn crypto_aead_unlock
function decrypts the ciphertext.
.Em Always check the return value .
.\" AEAD
.Pp
The
.Fn crypto_aead_lock
and
.Fn crypto_aead_unlock
functions are variants of
.Fn crypto_lock
and
.Fn crypto_unlock ,
permitting additional data.
Additional data is authenticated, but
.Em not
encrypted.
.Pp
.Bf Em
Note: using these functions is discouraged:
if the data you are transmitting is worth authenticating, it is probably
worth encrypting as well.
Do so if you can, using
.Fn crypto_lock
and
.Fn crypto_unlock .
.Ef
.Pp
If you must send unencrypted data, remember that you cannot trust
unauthenticated data,
.Em including the length of the additional data .
If you transmit that length over the wire, you must authenticate it.
(The easiest way to do so is to append that length to the additional
data before you call
.Fn crypto_aead_lock
or
.Fn crypto_aead_unlock ) .
Otherwise, an attacker could provide a false length, effectively moving
the boundary between the additional data and the ciphertext or possibly
causing buffer overflows.
If however the length of the additional data is implicit (fixed size)
or self-contained (such as length appending or null termination), you do
not need to authenticate it explicitly.
.Pp
The
.Fn crypto_aead_lock
function encrypts and authenticates a plaintext and authenticates
additional data.
It can be decrypted by the
.Fn crypto_aead_unlock
function.
Arguments that are already documented above will not be repeated here.
The arguments are:
.Bl -tag -width Ds
.It Fa ad
additional data.
This can be any arbitrary byte sequence.
It will not be encrypted.
.It Fa ad_size
length of the additional data.
.El
.Pp
If
.Fa ad
is
.Dv NULL
and
.Fa ad_size
is zero, these functions behave like
.Xr crypto_lock 3monocypher
and
.Xr crypto_unlock 3monocypher .
This can be useful if your protocol somehow requires you to
send unencrypted data.
.Pp
Unlocking proceeds in two steps: first, we authenticate the ciphertext
and additional data with the provided MAC.
If it has been corrupted, the
.Fn crypto_aead_unlock
function returns immediately,
without decrypting the message.
If the message is genuine, the
.Fn crypto_aead_unlock
function decrypts the ciphertext.
.Em Always check the return value .
.Pp
An incremental interface is available; see
.Xr crypto_lock_init 3monocypher .
.Sh RETURN VALUES
The
.Fn crypto_lock
and
.Fn crypto_aead_lock
functions return nothing.
They cannot fail.
The
.Fn crypto_unlock
and
.Fn crypto_aead_unlock
functions return 0 on success or -1 if the message was corrupted
(i.e.
.Fa mac
mismatched the combination of
.Fa key ,
.Fa nonce ,
.Fa ad
and
.Fa cipher_text ) .
Corruption can happen because of transmission errors, programmer error
(e.g. failed to parse the protocol properly and thus supplied only part
of the expected
.Fa cipher_text )
or an attacker's interference.
.Sh EXAMPLES
Encryption:
.Bd -literal -offset indent
uint8_t key[32], nonce[24];
uint8_t mac[16];
char plain_text[] = "This does not have to be literally text.";
uint8_t cipher_text[51]; /* strlen(plain_text) + terminating NUL */

/* ...Generate a key, as well as a random nonce... */

crypto_lock(mac, cipher_text, key, nonce, plain_text,
        sizeof(plain_text));

/* You can now transmit over the network:
 * - cipher_text
 * - nonce
 * - mac
 */
.Ed
.Pp
To decrypt the above:
.Bd -literal -offset indent
uint8_t key[32], nonce[24];
uint8_t mac[16];
char plain_text[51]; /* strlen(plain_text) + terminating NUL */
uint8_t cipher_text[51];
int ret;

/* Ensure that the key and nonce match the ones used in the
 * encryption process.
 *
 * Now read mac and cipher_text from the network; nonce as well if it
 * was sent along.
 */

ret = crypto_unlock(plain_text, key, nonce, mac, cipher_text,
        sizeof(cipher_text));
if (ret != 0) {
        /* Message corrupted; possibly an attacker is interfering
         * with the connection.
         */
}
.Ed
.Sh SEE ALSO
.Xr crypto_key_exchange 3monocypher ,
.Xr crypto_lock_init 3monocypher ,
.Xr intro 3monocypher
.Sh IMPLEMENTATION DETAILS
These functions implement the XChacha20 (encryption) and Poly1305 (MAC)
primitives.
.Pp
The
.Fn crypto_aead_lock
and
.Fn crypto_aead_unlock
functions do not authenticate the length themselves for simplicity,
compatibility, and efficiency reasons:
most of the time, the length of the additional data is either fixed or
self-contained, and thus outside of attacker control.
It also makes them compatible with
.Fn crypto_lock
and
.Fn crypto_unlock
when the size of the additional data is zero, and simplifies the
implementation.
